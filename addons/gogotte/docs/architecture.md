# Architecture

## Design Principles
### Entry Point
- gogotte acts as a pre-run hook for Gut. It generates a test file for each feature that will be run and adds it to Gut.
- The hook also gathers the step definitions and puts them in a static variable in StepLibrary so that the test files can run them.

### Logging
- Like a lot of Gherkin frameworks, gogotte logs the content of the feature as it runs.
- When a runtime error is thrown, the user must be able to tell which step in the feature caused it; this is why the compiled .out.gd file contains a function call for each step. This function call gets injection into the callstack of a runtime error.

### Error Handling
- gdscript assert() SHALL be used to halt Gut upon any parsing or gathering error.
This simplifies error handling a lot.

### Testing
- gogotte itself is tested using a Gut suite (in the ./addons/gogotte/selftest/ folder).

## Control Flow
1. User starts Gut via GUI or command line, making sure that GogotteHookScript is set as the Pre-Run Hook for Gut.

2. GutMain calls GogotteHookScript.run().

3. GogotteHookScript.run() calls GogotteMain.run().
    - The reason this indirection exists is to allow the user to extend GogotteHookScript to chain any other plugins they might have,
      and to keep the namespace of GogotteMain clean.
    - GogotteMain.run():
        - Retrieves config from .gogotteConfig
        - Calls FeatureCollector.collect() on the configured feature dirs.

4. FeatureCollector.collect():
    - Looks in each directory configured in Gut. For each feature file found:
        - Calls parse_feature.py against the feature file.
        - parse_feature.py returns an AST as JSON.
    - collect() returns all collected feature objects.

5. GogotteMain.run() calls GogotteCompiler.compile() on the feature list.
    - compile_feature() turns a feature AST into a script that extends GogotteTest.
    - The GogotteTest shall contain:
        - a FEATURE_AST const containing the feature AST.
        - a test_* method for each scenario in the feature.
        - Each test_* method shall create a different GogotteScenario from FEATURE_AST
          and then call run() on it.
    - All scripts are placed in the /gogotte/_out/ directory.

6. GogotteMain.run() calls GutMain.add_directory() on /gogotte/_out/.

7. GogotteMain.run() calls StepCollector.collect() w/ each step dir.
    - StepCollector.collect() looks in each step directory. For each step script found:
        - Checks that it has the step dictionary
        - Loads the script
        - collect() returns an Array of StepDefs.
            - Each StepDef:
                - Includes a compiled regex
                - Is guaranteed to have a function with the correct signature

8. GogotteMain.run() calls StepLibrary.set_steps(), which sets steps globally.
    - N.B: StepLibrary can't be instantiated and has only static methods.
    - This is because a global is the simplest way to pass the collected steps from GogotteMain to the compiled steps.

9. GogotteMain.run() adds the generated scripts to Gut.

10. GogotteMain.run() ends and control is passed back to Gut.

## GogotteTest
The GogotteTest class extends GutTest. The classes generated by GogotteCompiler all extend GogotteTest.

## Step Data
### Step Classes
The user shall define steps inside of step classes.

A step class shall be a Godot class with a variable `steps`, which is a Dictionary where
- Keys: step patterns (Strings).
- Values: step definitions (Callables).

A bit of JS-like gaslighting actually makes for one of the more ergonomic BDD step definition styles. It's really elegant.
```gdscript
var steps: Dictionary = {

    "x is equal to {number}":
    func (t: GogotteTest, number: String) -> void:
        t.ctx['x'] = int(number),

    "we add {number} to x":
    func (t: GogotteTest, number: String) -> void:
        t.ctx['x'] = t.ctx['x'] + int(number),

    "x should be {number}":
    func (t: GogotteTest, number: String) -> void:
        t.assert_eq(t.ctx['x'], int(number), "x was not correct")
        t.gut.p("OK"),

}
```
Don't forget the comma on the final line of each step.

### Step Patterns
A step pattern is a string matching the part of a step AFTER the Gherkin keyword.

For example, the step pattern "the sun rises in the East" matches all of these steps:
```
Given the sun rises in the East
 When the sun rises in the East
 Then the sun rises in the East
  And the sun rises in the East
```

### Placeholders
A step pattern may have placeholders with `{}`. For example, the pattern "the sun rises in the {direction}" will match the step `Given the sun rises in the West` and pass the String "West"
as the first argument to the step.

Strings are the only data type that can be passed through placeholders.

### Step Definitions
A step definition is the Callable corresponding to a step pattern.

The Callable must accept a GogotteTest as an argument.

For steps with placeholders, the Callable must additionally
accept a String for every placeholder in the order that they appear in the pattern.

The step may call any method of the GogotteTest object.
