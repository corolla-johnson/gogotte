## Extension to GutTest.
## GogotteCompiler in turn generates extensions to this class.
## See example/_out_specimen/test_specimen.gd for a specimen of a subclass generated by GogotteCompiler.
class_name GogotteTest
extends GutTest

var ROW_INDENT: int = 10

## Context dictionary for sharing data between steps.
var ctx: Dictionary = {}

## Part of AST
var _scenarios: Variant = null

## Docstring for the currently executing step.
## Can be String or null.
var docstring: Variant = null

## Datatable for the currently executing step.
## Can be Array or null.
var datatable: Variant = null

func before_all() -> void:
    # Print Feature heading before each feature.
    var ast: Variant = get("FEATURE_AST")
    if ast and ast.feature.has(name):
        gut.p(str("Feature: ", ast.feature.name), 1)
        if ast.feature.has("description") and len(ast.feature.description) > 0:
            gut.p(ast.feature.description, 1)

func before_each() -> void:
    # We clear the context dictionary before each test.
    ctx.clear()

# Overrides _fail() in GutTest.
func _fail(text: String) -> void:
    # We print a stack trace on failure.
    gut.p("[Stack Trace]:")

    # We print only slice(2, -3) of the stack in order to exclude stack cruft created by GUT and Gogotte.
    for frame in get_stack().slice(2, -3):
        gut.p(str("  ", frame['source'], ":",
                  frame['line'], " in ", frame['function'], "()"))

    # Return control to the normal GutTest _fail().
    super(text)

## Executes a step.
func _step(keyword: String,
           text: String,
           dataTable: Variant = null,
           docString: Variant = null) -> void:
    _print_step(keyword, text, dataTable, docString)
    _exec_step(keyword, text, dataTable, docString)

## Gets the whitespace needed to right-align 'keyword' to position 'kw_pos'.
func _get_right_align_whitespace(kw_pos: int, keyword: String) -> String:
    var indent: String = ""
    assert(len(keyword) <= kw_pos)
    for i in range(kw_pos - len(keyword)):
        indent += " "
    return indent

func _print_step(keyword: String,
                 text: String,
                 dataTable: Variant = null,
                 docString: Variant = null) -> void:
    var indent: String = _get_right_align_whitespace(ROW_INDENT, keyword)
    gut.p(str(indent, keyword, text), 1)

    # Prints the DataTable if the step has one.
    if dataTable != null:
        # First find the widest cell in each column
        var col_widths = []
        for i in range(len(dataTable.rows[0].cells)):
            col_widths.append(-1)
        for row in dataTable.rows:
            for i in range(len(row.cells)):
                col_widths[i] = maxi(col_widths[i],
                                     len(str(row.cells[i].value)))

        # Actually print each row
        var row_indent = _get_right_align_whitespace(ROW_INDENT, "")
        for row in dataTable.rows:
            var row_str: String = row_indent
            for i in range(len(row.cells)):
                row_str += _get_right_align_whitespace(col_widths[i], row.cells[i].value)
                row_str += str(row.cells[i].value)
                row_str += ' | '
            gut.p(row_str, 1)

    # Prints the docstring if the step has one.
    if docString != null:
        var row_indent = _get_right_align_whitespace(ROW_INDENT, "")
        var content_lines = docString.split("\n")
        gut.p(str(row_indent, "\"\"\""), 1)
        for line in content_lines:
            gut.p(str(row_indent, line), 1)
        gut.p(str(row_indent, "\"\"\""), 1)

func _exec_step(keyword: String,
                text: String,
                dataTable_arg: Variant = null,
                docString_arg: Variant = null) -> void:
    # Try to match the step.
    var matched = StepLibrary.match_step(text)
    assert(matched != null, str("[Gogotte]: Undefined step: ", text))

    # Build the argument array.
    var step_def: StepDef = matched[0]
    var args = [self]
    args.append_array(matched.slice(1))

    # Load the docstring and datatable.
    if dataTable_arg != null:
        datatable = []
        for row in dataTable_arg.rows:
            var row_values = []
            for col in row.cells:
                row_values.append(col.value)
            datatable.append(row_values)
    else:
        datatable = null

    if docString_arg != null:
        docstring = docString_arg
    else:
        docstring = null

    # Call the function.
    step_def.callable.callv(args)

## Begins the scenario.
func _begin(scenario_idx: int, outline_idx: int = -1) -> void:
    var scenario = _get_scenario(scenario_idx)

    var outline_suffix = (" - Example #" + str(outline_idx + 1)) if outline_idx != -1 else ""

    # Print out the scenario heading.
    gut.p(str("Scenario: ", scenario.name, outline_suffix), 1)
    # t.gut.p(str("Scenario: ", scenario.name), 1)
    if scenario.has("description") and len(scenario.description) > 0:
        gut.p(scenario.description, 1)

## Begins the scenario.
func _end(scenario_idx: int) -> void:
    # Extra newline
    gut.p("", 1)

func _get_scenario(idx: int) -> Dictionary:
    if _scenarios == null:
        _scenarios = []
        var ast: Variant = get("FEATURE_AST")
        # Get *all* scenarios in the feature. We will execute just the one we are interested in.
        var scenarios: Array = []
        for child in ast.feature.children:
            if child.has("scenario"):
                _scenarios.append(child.scenario)

            if child.has("rule"):
                for grandchild in child.rule.children:
                    if grandchild.has("scenario"):
                        _scenarios.append(grandchild.scenario)

    return _scenarios[idx]
