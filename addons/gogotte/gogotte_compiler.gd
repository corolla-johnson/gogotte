## Class that compiles feature ASTs into GUT test scripts.
## See example/_out_specimen/test_specimen.gd for a specimen of a subclass generated by GogotteCompiler.
class_name GogotteCompiler

var gut: GutMain = null

## If no metadata is available, gogotte will throw .out.gd files in here.
var FALLBACK_OUT_DIR = "res://addons/gogotte/_out/"

func _init(gut: GutMain) -> void:
    self.gut = gut

## Cleans the feature directories by deleting all .out.gd files.
func clean_feature_dirs(features: Array) -> void:
    var feature_dirs = []

    # Get a list of all unique feature directories
    for feature: Dictionary in features:
        if feature.has("_gogotte_metadata") and feature._gogotte_metadata.has("feature_path"):
            feature_dirs.append(feature._gogotte_metadata.feature_path.get_base_dir())

    for dir_path in feature_dirs:
        var dir = DirAccess.open(dir_path)
        assert(dir != null, str("[Gogotte]: Failed to access feature directory at ", dir_path))

        # Remove all .out.gd files in the _out directory
        for file in dir.get_files():
            if file.ends_with(".out.gd") or file.ends_with(".out.json"):
                var file_path = dir_path.path_join(file)
                var err = dir.remove(file)
                assert(err == OK, str("[Gogotte]: Failed to remove file ", file_path))
                gut.p(str("[Gogotte]: Removed file ", file_path), 2)

## Compiles a list of feature ASTs into test scripts in the _out directory.
## Each feature is turned into a single test file.
func compile(features: Array, save_ast: bool = false) -> void:
    # Clean the feature directories first
    clean_feature_dirs(features)

    # Keep track of filenames to avoid collisions
    var used_filenames = {}

    for feature in features:
        # Get the original feature filename from metadata.
        # We will use it to create a GUT test with the same filename.
        var base_filename = ""
        var base_dir = ""
        if feature.has("_gogotte_metadata") and feature._gogotte_metadata.has("filename"):
            base_filename = feature._gogotte_metadata.filename.get_basename()
        else:
            # Fallback to feature name if metadata is not available
            base_filename = _sanitize_filename(feature.feature.name)

        if feature.has("_gogotte_metadata") and feature._gogotte_metadata.has("feature_path"):
            base_dir = feature._gogotte_metadata.feature_path.get_base_dir()
        else:
            base_dir = FALLBACK_OUT_DIR

        var output_filename = base_filename

        # Ensure the filename is unique; if not, add a number
        var counter = 0
        while used_filenames.has(output_filename):
            output_filename = base_filename + "_" + str(counter)
            counter += 1

        # Add the final filename to used_filenames
        used_filenames[output_filename] = true

        # Dump AST first
        var ast_path = base_dir.path_join(output_filename + ".out.json")
        _write_script(ast_path, JSON.stringify(feature, "    "))
        gut.p(str("[Gogotte]: Saved AST to ", ast_path), 2)

        # Generate the script
        var script_content = _generate_script(feature)

        # Send the script back to the original directory
        var script_path = base_dir.path_join(output_filename + ".out.gd")
        _write_script(script_path, script_content)
        gut.p(str("[Gogotte]: Compiled feature to ", script_path), 2)

        # Attach this to the metadata
        feature._gogotte_metadata['script_path'] = script_path

## Generates a GDScript file for a single feature.
func _generate_script(feature: Dictionary) -> String:
    var script = "extends GogotteTest\n\n"

    # Add the feature AST as a constant
    script += "# This contains the full AST of the Gherkin feature.\n"
    script += "var FEATURE_AST: Dictionary = " + JSON.stringify(feature) + "\n\n"

    # Add test methods for each scenario
    script += "# These always begin with test_scenario_x followed by the scenario's name if available.\n"
    script += "# The index disambiguates them if they have no name.\n"

    var scenarios = _extract_scenarios(feature)
    assert(scenarios.size() > 0, "[Gogotte]: Feature has no scenarios")

    for i in range(scenarios.size()):
        var scenario = scenarios[i]
        var scenario_name = scenario.name if scenario.has("name") else ""
        var sanitized_name = _sanitize_method_name(scenario_name)

        # Index for 'scenario outline'; -1 means not applicable
        var outline_idx = -1
        var n_examples = 1
        if scenario.keyword == "Scenario Outline":
            outline_idx = 0
            n_examples = len(scenario.examples[0].tableBody)

        for j in range(n_examples):
            script += _print_scenario(sanitized_name, i, outline_idx, feature, scenario)
            outline_idx += 1

    return script

## Retrieves the placeholder values for a Scenario Outline example.
func _get_placeholder_dict(
        scenario: Dictionary,
        outline_idx: int
        ) -> Dictionary:
    var retval = {}
    if outline_idx == -1:
        return retval

    for col in range(len(scenario.examples[0].tableHeader.cells)):
        var key = "<" + scenario.examples[0].tableHeader.cells[col].value + ">"
        retval[key] = (
            scenario.examples[0].tableBody[outline_idx].cells[col].value
        )
    return retval

## Prints the scenario to code.
func _print_scenario(
        sanitized_name: String,
        scenario_idx: int,
        outline_idx: int,
        feature: Dictionary,
        scenario: Dictionary) -> String:
    var script = ""

    # Skip if scenario has 'skip' tag
    for tag in scenario.get("tags", []):
        if tag.name == '@skip':
            return ""

    # Get placeholder replacements
    var placeholders = _get_placeholder_dict(scenario, outline_idx)

    # Write scenario signature
    if sanitized_name.length() > 0:
        script += "func test_scenario_" + str(scenario_idx) + "_" + sanitized_name
    else:
        script += "func test_scenario_" + str(scenario_idx)
    if outline_idx != -1:
        script += "_" + str(outline_idx)
    script += "() -> void:\n"

    # Write _begin call
    script += '    _begin(' + str(scenario_idx) + ', ' + str(outline_idx) + ')\n'

    # Write calls to background steps
    var background = _extract_background(feature)
    if background != null:
        for step in background.steps:
            script += _print_step(step, {})

    # Write calls to scenario steps
    for step in scenario.steps:
        script += _print_step(step, placeholders)

    # End scenario
    script += '    _end(' + str(scenario_idx) + ')\n\n'

    return script

func _print_step(step: Dictionary, replacements: Dictionary = {}) -> String:
    var script: String = '    '

    # Replace placeholders for Scenario Outline
    var text: String = step.text
    for key in replacements:
        text = text.replace(key, replacements[key])
    text = text.c_escape()

    script += "_step("
    script += '"' + step.keyword + '", "' + text + '", '

    if step.has("dataTable"):
        script += JSON.stringify(step.dataTable) + ', '
    else:
        script += 'null, '

    if step.has("docString"):
        script += '"' + step.docString.content.c_escape() + '"'
    else:
        script += 'null'

    script += ')\n'

    return script

## Extracts background from a feature.
func _extract_background(feature: Dictionary) -> Variant:
    assert(feature.has("feature"), "[Gogotte]: Invalid feature AST - missing 'feature' key")
    assert(feature.feature.has("children"), "[Gogotte]: Invalid feature AST - missing 'children' key")

    for child in feature.feature.children:
        if child.has("background"):
            return child.background

    return null

## Extracts all scenarios from a feature.
## Returns an array of scenario dictionaries.
func _extract_scenarios(feature: Dictionary) -> Array:
    var scenarios = []

    assert(feature.has("feature"), "[Gogotte]: Invalid feature AST - missing 'feature' key")
    assert(feature.feature.has("children"), "[Gogotte]: Invalid feature AST - missing 'children' key")

    for child in feature.feature.children:
        if child.has("scenario"):
            scenarios.append(child.scenario)

        if child.has("rule"):
            for grandchild in child.rule.children:
                if grandchild.has("scenario"):
                    scenarios.append(grandchild.scenario)

    return scenarios

## Sanitizes a string to be used as a filename.
func _sanitize_filename(name: String) -> String:
    assert(name != null && name.length() > 0, "[Gogotte]: Feature name cannot be empty")

    var sanitized = name.to_lower()
    sanitized = sanitized.replace(" ", "_")
    # Remove any non-alphanumeric characters except underscores
    var regex = RegEx.new()
    regex.compile("[^a-z0-9_]")
    sanitized = regex.sub(sanitized, "", true)
    return sanitized

## Sanitizes a string to be used as a method name.
func _sanitize_method_name(name: String) -> String:
    var sanitized = name.to_lower()
    sanitized = sanitized.replace(" ", "_")
    # Remove any non-alphanumeric characters except underscores
    var regex = RegEx.new()
    regex.compile("[^a-z0-9_]")
    sanitized = regex.sub(sanitized, "", true)
    return sanitized

## Writes a script to a file.
func _write_script(path: String, content: String) -> void:
    var dir_path = path.get_base_dir()
    var dir = DirAccess.open(dir_path)

    assert(dir != null, str("[Gogotte]: Failed to access directory ", dir_path))

    var file = FileAccess.open(path, FileAccess.WRITE)
    assert(file != null, str("[Gogotte]: Failed to open file for writing: ", path))

    file.store_string(content)
    file.close()
    gut.p(str("[Gogotte]: Wrote test file to ", path), 2)
